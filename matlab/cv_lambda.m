function [ lambda ] = cv_lambda(X,Y,sigma,nystrom_rank)
%CV_LAMBDA Runs 5-fold cross-validation to find a suitable lambda. Lambdas
%are chosen based on the estimated spectrum generated by the Nystrom
%approximation. 

%% Set initial values
FOLDS = 5;
[N,d] = size(X);
nystrom_m = nystrom_rank*2;
sflag = 1; %determines whether we need to subsample in each section
if nystrom_rank > 4 * N/FOLDS
    sflag = 0;
end
    
%% Split into sections
fold_sizes = zeros(FOLDS,1);
bigs = mod(N,FOLDS);
fold_sizes(1:bigs) = ceil(N/FOLDS);
fold_sizes(bigs+1:end) = floor(N/FOLDS);
shuffled = randperm(N);
sample = 1:nystrom_m - fold_sizes(1);


%% Specify lambda choices
num_gams = 4192;
curr_sample = createsample(X,num_gams*2,[],'random');
[~, spectrum] = nystromeig(X,sigma,curr_sample,num_gams,0);
spectrum = spectrum(end:-1:1);


%% Choose ideal lambda
errors = zeros(size(spectrum));

for i = 1:FOLDS
    sample = sample + fold_sizes(i);
    curr_idx = diff(1:N,sample);
    curr_idx = shuffled(curr_idx);
    
    curr_sample = createsample(X(curr_idx,:),nystrom_m,[],'random');
    [U, L] = nystromeig(X(curr_idx,:),sigma,curr_sample,nystrom_rank);
    
    [Qb,R] = qr(U,0);
    [Qs,D] = eig(R*L*R');
    D = diag(D);
    Q = Qb*Qs;
    
    y = Y(sample);
    qy = (Q'*y)./D;
    base_res = norm(y - Q*qy,2)^2;
    
    dcount = length(D); 
    for j = 1:length(spectrum)
        %Figure out last value to include
        while D(dcount) < spectrum(j)
            dcount = dcount - 1;
            if dcount == 0, break; end;
        end
        
        errors(j) = errors(j) + sqrt((base_res + norm(qy(dcount+1:end),2)^2));
        
    end

end

errors./FOLDS;
lambda = min(errors);


